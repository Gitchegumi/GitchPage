<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DebtPipe - Bill Tracker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; margin: 0; padding: 20px; background: #f1f5f9; color: #475569; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #1e293b; margin-bottom: 20px; }
        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #475569; }
        input, select { padding: 8px; border: 1px solid #cbd5e1; border-radius: 4px; width: 200px; }
        button { padding: 10px 20px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #2563eb; }
        #results { margin-top: 30px; }
        .debt-table { width: 100%; border-collapse: collapse; font-size: 10pt; margin-top: 10px; }
        .debt-table th, .debt-table td { border: 1px solid #e2e8f0; padding: 4px; text-align: center; }
        .debt-table th { background: #1e293b; color: #f1f5f9; font-weight: bold; }
        .debt-table .debt-name { text-align: left; font-weight: bold; background: #f8fafc; position: sticky; left: 0; z-index: 10; }
        .paid-row { background-color: #ecfdf5; }
        .custom-row { background-color: #eff6ff; }
        .header-month { min-width: 110px; }
        .checkbox-cell { width: 24px; }
        .payment-input { width: 60px; padding: 2px; border: 1px solid #cbd5e1; border-radius: 4px; text-align: center; }
        .flow-remaining { font-weight: bold; color: #64748b; }
        .no-results { color: #64748b; font-style: italic; }
    </style>
</head>
<body>
    <div class="container">
        <h1>DebtPipe - Bill Tracker</h1>

        <!-- Input Form -->
        <div id="inputForm">
            <div class="form-group">
                <label for="billsInput">Bills (JSON array)</label>
                <textarea id="billsInput" rows="4" style="width:100%; padding:8px; border:1px solid #cbd5e1; border-radius:4px; font-family:monospace;" placeholder="[{'name':'Visa','dueDate':1,'statementBalance':1200}, ...]"></textarea>
            </div>
            <div class="form-group">
                <label for="paymentsInput">Monthly Payments (JSON mapping)</label>
                <textarea id="paymentsInput" rows="3" style="width:100%; padding:8px; border:1px solid #cbd5e1; border-radius:4px; font-family:monospace;" placeholder="[{'month':1,'Visa':200,'Mastercard':150}, ...]"></textarea>
            </div>
            <button onclick="generateReport()">Generate Timeline</button>
            <button onclick="downloadPDF()">Download PDF</button>
        </div>

        <!-- Results -->
        <div id="results"></div>
    </div>

    <script>
        // ========================================================================
        // DebtPipe Bill Tracking with Custom Payments and Dynamic Timeline
        // ========================================================================

        // State management
        let debtBills = []; // static bill definitions
        let debtPayments = {}; // { key: boolean } for checkbox paid state (interactive)
        let debtCustomPayments = {}; // { key: amount } for custom payment amounts
        let lastResult = null; // stores the latest simulation result

        // Load from localStorage on startup
        function loadDebtData() {
            const savedBills = localStorage.getItem('debtBills');
            const savedPayments = localStorage.getItem('debtPayments');
            const savedCustom = localStorage.getItem('debtCustomPayments');

            if (savedBills) {
                debtBills = JSON.parse(savedBills);
                document.getElementById('billsInput').value = JSON.stringify(debtBills, null, 2);
            }
            if (savedPayments) {
                debtPayments = JSON.parse(savedPayments);
            }
            if (savedCustom) {
                debtCustomPayments = JSON.parse(savedCustom);
            }
        }

        // Save to localStorage
        function saveDebtData() {
            localStorage.setItem('debtBills', JSON.stringify(debtBills));
            localStorage.setItem('debtPayments', JSON.stringify(debtPayments));
            localStorage.setItem('debtCustomPayments', JSON.stringify(debtCustomPayments));
        }

        // Format number as currency with 2 decimals
        function fmt(n) {
            return Number(n).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }

        // Recalculate timeline based on custom payments and carry forward
        function recalculateTimeline() {
            if (!lastResult || !lastResult.timeline) return;

            // Clone timeline deeply
            const newTimeline = JSON.parse(JSON.stringify(lastResult.timeline));

            // For each debt, apply custom payments and carry balance forward
            for (const name of lastResult.debtNames) {
                let carryBalance = 0; // unpaid amount carried to next month

                for (let i = 0; i < newTimeline.length; i++) {
                    const step = newTimeline[i];
                    const start = step.startingBalances[name] || 0;
                    const planned = step.plannedPayments[name] || 0;
                    const interest = step.interests[name] || 0;
                    const key = `${name}::${i}`;
                    const customAmt = debtCustomPayments[key] || 0;
                    const isPaid = debtPayments[key] === true;

                    // Determine actual payment applied this month
                    let actualPaid = 0;
                    if (isPaid) {
                        actualPaid = customAmt > 0 ? customAmt : planned;
                    } else if (customAmt > 0) {
                        actualPaid = customAmx; // allow partial custom payments without marking as fully paid
                    } else if (planned > 0) {
                        actualPaid = planned;
                    }

                    // Calculate balance before interest
                    let balanceBeforeInterest = carryBalance + start - actualPaid;

                    // Apply interest only on positive balance
                    let interestAccrued = 0;
                    if (balanceBeforeInterest > 0) {
                        interestAccrued = interest;
                    }

                    let newBalance = balanceBeforeInterest + interestAccrued;

                    // Update step values for rendering
                    step.payments[name] = actualPaid;
                    step.balances[name] = newBalance;
                    step.interests[name] = interestAccrued;

                    // Carry forward to next month
                    carryBalance = newBalance;
                }
            }

            lastResult.timeline = newTimeline;
            renderTimeline(lastResult);
        }

        // Handle checkbox toggle (mark as paid/unpaid)
        function onPaidToggle(debtName, monthIdx) {
            const key = `${debtName}::${monthIdx}`;
            debtPayments[key] = !debtPayments[key];
            saveDebtData();
            recalculateTimeline();
        }

        // Handle custom payment input change
        function onCustomPaymentChange(debtName, monthIdx, value) {
            const key = `${debtName}::${monthIdx}`;
            const numVal = parseFloat(value) || 0;
            if (numVal <= 0) {
                delete debtCustomPayments[key];
            } else {
                debtCustomPayments[key] = numVal;
            }
            saveDebtData();
            recalculateTimeline();
        }

        // Render the interactive timeline table
        function renderTimeline(result) {
            const container = document.getElementById('results');
            if (!result || !result.timeline || result.timeline.length === 0) {
                container.innerHTML = '<p class="no-results">No timeline data. Generate a report first.</p>';
                return;
            }

            const { timeline, debtNames } = result;
            const displayMonths = timeline.slice(0, 6); // only show first 6 months for PDF and UI as requested

            const tableHTML = `
                <div style="margin-top:20px;">
                    <h3>Bill Tracking Timeline</h3>
                    <p style="font-size:9pt; color:#64748b;">Check "Paid" to mark bill as paid. Enter custom payment amounts to apply partial payments. Remaining balance flows forward automatically.</p>
                    <table class="debt-table">
                        <thead>
                            <tr>
                                <th rowspan="2" style="min-width:150px;">Debt Name</th>
                                ${displayMonths.map(() => `<th colspan="2">Payment & Balance</th>`).join('')}
                            </tr>
                            <tr>
                                ${displayMonths.map(step => `
                                    <th>Paid</th>
                                    <th class="flow-remaining">Flow Remaining</th>
                                `).join('')}
                            </tr>
                        </thead>
                        <tbody>
                            ${debtNames.map(name => `
                                <tr>
                                    <td class="debt-name">${name}</td>
                                    ${displayMonths.map((step, monthIdx) => {
                                        const start = step.startingBalances[name] || 0;
                                        const bal = step.balances[name];
                                        const key = `${name}::${monthIdx}`;
                                        const isPaid = debtPayments[key] === true;
                                        const customAmt = debtCustomPayments[key] || 0;
                                        const isFullyPaid = bal <= 0.01 && start > 0;
                                        const rowClass = isFullyPaid ? 'paid-row' : (customAmt > 0 ? 'custom-row' : '');

                                        // Display values
                                        const displayBal = bal <= 0 ? 'PAID' : '$' + fmt(bal);

                                        return `
                                            <td class="${rowClass}">
                                                <input type="checkbox" ${isPaid ? 'checked' : ''} onclick="onPaidToggle('${name}', ${monthIdx})" title="Mark bill as paid">
                                                <input type="number" min="0" step="0.01" value="${customAmt.toFixed(2)}" class="payment-input" onchange="onCustomPaymentChange('${name}', ${monthIdx}, this.value)" placeholder=" Amt">
                                                <div style="margin-top:2px; font-size:9pt;">
                                                    ${displayBal}
                                                </div>
                                            </td>
                                        `;
                                    }).join('')}
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>

                <div style="margin-top:30px; padding:15px; background:#f8fafc; border:1px solid #e2e8f0; border-radius:8px;">
                    <h4>Instructions</h4>
                    <ul style="font-size:9pt; color:#475569;">
                        <li>Check the box to mark a bill as paid for that month. The full planned payment will be applied unless you specify a custom amount.</li>
                        <li>Enter a custom amount to pay a partial amount (e.g., a windfall across multiple bills).</li>
                        <li>Remaining balance (Flow Remaining) updates automatically and carries to the next month with interest.</li>
                        <li>Changes are saved automatically to your browser's local storage.</li>
                    </ul>
                </div>
            `;

            container.innerHTML = tableHTML;
        }

        // Generate a sample report with dummy data (for demo/testing)
        // In production, this would be the actual DebtPipe simulation output
        function generateReport() {
            // Example: read bills and payment plans from inputs (simplified)
            try {
                const bills = JSON.parse(document.getElementById('billsInput').value || '[]');
                const payments = JSON.parse(document.getElementById('paymentsInput').value || '[]');

                // Build timeline with starting balances, planned payments, and interest
                const months = 12;
                const debtNames = bills.map(b => b.name);
                const timeline = [];

                // Simple interest rate for demo (could be configurable)
                const annualRate = 0.08;
                const monthlyRate = annualRate / 12;

                for (let m = 0; m < months; m++) {
                    const step = {
                        date: new Date(2025, m, 1).toLocaleDateString('en-US', { year: 'numeric', month: 'short' }),
                        startingBalances: {},
                        plannedPayments: {},
                        interests: {},
                        balances: {}
                    };

                    for (const bill of bills) {
                        const prevBal = (timeline.length > 0) ? timeline[timeline.length-1].balances[bill.name] || 0 : bill.statementBalance;
                        step.startingBalances[bill.name] = prevBal;
                        step.plannedPayments[bill.name] = bill.minPayment || (bill.statementBalance * 0.02); // example min payment
                        step.interests[bill.name] = prevBal * monthlyRate;
                        step.balances[bill.name] = prevBal + step.interests[bill.name] - step.plannedPayments[bill.name];
                    }

                    timeline.push(step);
                }

                lastResult = { timeline, debtNames };
                // Apply any persisted custom payments before initial render
                recalculateTimeline();
                return lastResult;
            } catch (e) {
                alert('Invalid input JSON. Please check format.');
                console.error(e);
                return null;
            }
        }

        // Download current view as PDF
        function downloadPDF() {
            const element = document.getElementById('results');
            if (!element || !element.innerHTML.trim()) {
                alert('No timeline to export. Generate a report first.');
                return;
            }

            const opt = {
                margin: 10,
                filename: 'DebtPipe_Bill_Tracker.pdf',
                image: { type: 'jpeg', quality: 0.98 },
                html2canvas: { scale: 2, useCORS: true, letterRendering: true, scrollY: 0, scrollX: 0 },
                jsPDF: { unit: 'mm', format: 'a4', orientation: 'landscape' },
                pagebreak: { mode: ['avoid-all', 'css', 'legacy'] }
            };

            html2pdf().set(opt).from(element).save();
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => {
            loadDebtData();
        });
    </script>
</body>
</html>
